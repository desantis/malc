# malc

Mal (Make A Lisp) compiler

## Overview

[Mal](https://github.com/kanaka/mal) is Clojure inspired Lisp language invented
by Joel Martin as a learning tool.  It has interpreter implementations in dozens
of programming languages, including self-hosted interpreter written in Mal
itself.

malc is a compiler for Mal, written in Mal itself.  It compiles a Mal program to
[LLVM assembly language (IR)](http://llvm.org/docs/LangRef.html), and then uses
the LLVM optimizer, assembler and gcc linker to produce a binary executable.

This project main goal was a way for me to learn about Lisp, compilation and
LLVM.  It is not intended for use in any serious application or system.


## Installation

### Dependencies

malc depends on LLVM, of course. Moreover, the executables generated by malc
are dynamically linked with libstdc++ (for exception handling routines), with
the Boehm Garbage Collection shared library (`libgc.so`) and with the readline
shared library.

To install the dependencies on Debian/Ubuntu:

    sudo apt-get install llvm libstdc++ libgc-dev libreadline6

To install the dependencies on RedHat/CentOS:

    sudo yum install llvm libstdc++ gc-devel readline

Besides these dependencies, malc needs a working Mal interpreter in order to
compile itself.  malc comes bundled with the Ruby implementation of the Mal
interpreter (in `mal-interpreter` directory) for an easier invocation of malc.
Hence, a working Ruby runtime is required.  Alternatively, you can choose
another Mal interpreter implementation using the `MAL_IMPL` environment
variable; see below.

### Bootstrapping

The main logic of malc is the `mal-to-llvm` program, written in Mal itself.  As
part of the installation, we compile mal-to-llvm with itself (you can go and
read this sentence again now).  The `bootstrap.sh` script does exactly that:

    ./bootstrap.sh

This will create the `mal-to-llvm` executable, which is used by the `malc`
wrapper script.  Now malc is ready to use.

By default, `bootstrap.sh` uses the bundled Ruby implementation of the Mal
interpreter.  Use the `MAL_IMPL` (path to the Mal implementation) and `MAL_PREFIX`
(program which runs the Mal implementation) environment variables to instruct
`bootstrap.sh` to use another Mal interpreter.  For example:

    MAL_PREFIX=python MAL_IMPL=../mal/python/stepA_mal.py ./bootstrap.sh

For compiled Mal interpreters just set `MAL_IMPL`; for example:

    MAL_IMPL=../mal/ocaml/stepA_mal ./bootstrap.sh


## Usage

    malc [-g] [-l] [-v] -c source_file.mal [-o executable_file]

Where the options are:

* `-h/-?`: Display the help message
* `-c FILENAME`: Mal source file name to compile
* `-g`: Enable debug mode (mark functions as external for clearer stack traces)
* `-l`: Keep intermediate LLVM IR filse
* `-o FILENAME`: Output executable file name
* `-v`: Enable verbose logging

### Basic usage

Run the `malc` as follows with the Mal program file:

    ./malc -c myprogram.mal

If successful, this will generate the executable `myprogram`.

Add the `-v` switch to enable verbose logging of the malc stages.

Add the `-o FILENAME` switch to chooose another name for the resulting
executable file:

    ./malc -c myprogram.mal -o prog

If successful,  this will generate the executable `prog`.

### Adding debug information

If you want to debug the binary (with gdb), use the `-g` switch:

    ./malc -g -c myprogram.mal

This will instruct the compiler to mark the generated LLVM functions with
`external` linkage type (as opposed to the `private` linkage type).  This
leaves the functions names in the resulting executable, thereby allowing more
readable stack traces; however, it might prevent the optimizer from inlining
some functions.

Note that currently malc doesn't add full-fledged debug information.

### Examining generated LLVM IR code

If you want to look at the LLVM code generated by malc, use the `-l` switch:

    ./malc -l -c myprogram.mal

This will generate `myprogram.ll` (the LLVM code produced by `mal-to-llvm`),
`myprogram.opt.ll` (LLVM code after the LLVM optimizer) and `myprogram` (the
executable file).

### Running malc with a Mal interpreter

By default malc uses the `mal-to-llvm` executable which is created during the
boostrapping step.  Since `mal-to-llvm` is written in Mal, you may chooose to
run it with any Mal interpreter you want, instead of running the compiled
(bootstrapped) executable. (At the time of writing there are
[49](https://github.com/kanaka/mal) Mal interpreter implementations!)

Use the `MAL_IMPL` (path to the Mal implementation) and `MAL_PREFIX`
(program which runs the Mal implementation) environment variables to instruct
malc to use another Mal interpreter.  For example:

    MAL_PREFIX=python MAL_IMPL=../mal/python/stepA_mal.py ./malc -c myprogram.mal

For compiled Mal interpreters just set `MAL_IMPL`; for example:

    MAL_IMPL=../mal/ocaml/stepA_mal ./malc -c myprogram.mal

At this point there's a limitation - when malc is invoked using a Mal
interpreter it must be invoked from the malc project root directory.


## Running tests

The functional tests for malc are under the `tests/` directory.

To run all the tests:

    ./runtests.sh

To run a specific test file:

    ./runtests.sh tests/integer_compare.mal


## Running performance tests

The Mal performance tests are copied over and can be run with:

    ./runperf.sh

Please note the caveat from [Mal's own
README](https://github.com/kanaka/mal#performance-tests):

> Warning: These performance tests are neither statistically valid nor
> comprehensive; runtime performance is a not a primary goal of mal. If you
> draw any serious conclusions from these performance tests, then please
> contact me about some amazing oceanfront property in Kansas that I'm willing
> to sell you for cheap.


## Implementation details

See [internals documentation](doc/internals.md).


## Additions to Mal

The following functions were added:

* `(os-exit EXITCODE)` - exits the process with the given integer exit code.
* `(gc-get-heap-size)` - Boehm GC's `GC_get_heap_size()`
* `(gc-get-total-bytes)` - Boehm GC's `GC_get_total_bytes()`

The following variables were added:

* `*ARGV0*` - string which holds the value of argv[0] from the executable
  `main()` entry function.


## What's missing?

A lot. See the [TODO list](doc/TODO.md).


## License

malc (make-a-lisp compiler) is licensed under the MPL 2.0 (Mozilla Public
License 2.0). See LICENSE.txt for more details.
