(load-file "utils.mal")
(load-file "instructions.mal")

(def! *current-reg* (atom 0))
(def! new-reg
  (fn* []
    (str "%r" (swap! *current-reg* inc))))

(def! *current-stack-reg* (atom 0))
(def! new-stack-reg
  (fn* []
    (str "%sr" (swap! *current-stack-reg* inc))))

(def! *current-label* (atom 0))
(def! new-label
  (fn* []
    (str "label" (swap! *current-label* inc))))

(def! *current-string-global* (atom 0))
(def! *strings-list* (atom []))
(def! add-string
  (fn* [str-val]
    (let* [str-num (swap! *current-string-global* inc)
           str-global (str "@str." str-num)
           len (inc (string/length str-val))
           def-line (str str-global "= private constant [" len " x i8] c\"" str-val "\\00\"")]
      (do
        (swap! *strings-list* conj def-line)
        str-global))))

(def! *native-funcs* (atom {}))
(def! add-native-func
  (fn* [name llvm-name]
    (do
      (swap! *native-funcs* assoc (symbol name) ['llvm-func (str "@" llvm-name)]))))

(def! debug
  (fn* [& args]
    (apply println "; DEBUG" args)))

(def! emit println)

(def! emit-label
  (fn* [name]
    (emit (str name ":"))))

(def! emit-assign-to-reg
  (fn* [result arg]
    (do
      (emit result "= call %mal_obj @identity(%mal_obj " arg ")")
      result)))

(def! compile-const-integer
  (fn* [result num]
    (do
      (emit result "= call %mal_obj @make_integer(i64" num ")")
      result)))

(def! compile-nil
  (fn* [result]
    (do
      (emit result "= call %mal_obj @make_nil()")
      result)))

(def! compile-true
  (fn* [result]
    (do
      (emit result "= call %mal_obj @make_true()")
      result)))

(def! compile-false
  (fn* [result]
    (do
      (emit result "= call %mal_obj @make_false()")
      result)))

(def! compile-const-bytearray
  (fn* [result type-num body]
    (let* [len-reg (new-reg)
           str-len (inc (string/length body))
           str-global (add-string body)]
      (do
        (emit len-reg "= add i32 0," str-len)
        (emit result "= call %mal_obj @mal_make_bytearray_obj(i32 " type-num ", i32 " len-reg ", i8* getelementptr([" str-len " x i8]* " str-global ", i32 0, i32 0))")
        result))))

(def! get-func
  (fn* [funcname]
    (or (get *instructions* funcname)
        (get @*native-funcs* funcname))))

(def! compile-apply
  (fn* [result ast env-type]
    (let* [funcname (first ast)
           funcobj (get-func funcname)
           functype (first funcobj)
           funcdetails (rest funcobj)
           argregs (map (fn* [p] (compile (new-reg) p env-type)) (rest ast))
           ;argregs (map compile-temp (rest ast))
           argregs-with-types (map (fn* [a] (str "%mal_obj " a)) argregs)]
      (do
        (debug "compile-apply:" result ast)
        (cond
          (= functype 'llvm-func)
            (emit result "= call %mal_obj" (first funcdetails) "(" (string/join ", " argregs-with-types) ")")
          'else
            (throw (str "Unknown function '" funcname "' type: " functype)))
        result))))

(def! emit-native-func
  (fn* [name llvm-name params body]
    (let* [params-with-types (map (fn* [p] (str "%mal_obj %"  p)) params)]
      (do
        (add-native-func name llvm-name)
        (emit "")
        (emit "")
        (emit "define private %mal_obj" (str "@" llvm-name) "(" (string/join ", " params-with-types) ") {")
        (compile "%funcresult" body 'native-func)
        (emit "ret %mal_obj %funcresult")
        (emit "}")
        (emit "")
        nil))))

(def! compile-if
  (fn* [result ast env-type]
    (let* [cond-exp (nth ast 1)
           true-exp (nth ast 2)
           false-exp (if (> (count ast) 3) (nth ast 3) nil)
           result-stack-reg (new-stack-reg)
           cond-reg (new-reg)
           tmp-true-result (new-reg)
           tmp-false-result (new-reg)
           true-label (new-label)
           false-label (new-label)
           after-if-label (new-label)]
      (do
        (emit result-stack-reg "= alloca %mal_obj")
        (compile cond-reg cond-exp env-type)
        (emit "switch %mal_obj" cond-reg ", label" (str "%" true-label)
              "[ %mal_obj 2, label" (str "%" false-label) "\n"
              "%mal_obj 4, label" (str "%" false-label) "]")
        (emit-label true-label)
        (compile tmp-true-result true-exp env-type)
        (emit "store %mal_obj" tmp-true-result ", %mal_obj*" result-stack-reg)
        (emit "br label" (str "%" after-if-label))
        (emit-label false-label)
        (compile tmp-false-result false-exp env-type)
        (emit "store %mal_obj" tmp-false-result ", %mal_obj*" result-stack-reg)
        (emit "br label" (str "%" after-if-label))
        (emit-label after-if-label)
        (emit result "= load %mal_obj*" result-stack-reg)
        result))))

(def! compile-list
  (fn* [result ast env-type]
    (let* [a0 (first ast)]
      (cond
        (= 'defmacro! a0)
          (do
            (eval ast)
            result)

        (= 'quote a0)
          (compile-literal result (nth ast 1) env-type)

        (= 'do a0)
          (let* [regs (map (fn* [a] (compile-temp a env-type)) (rest ast))]
            (if result
              (emit-assign-to-reg result (last regs))))

        (= 'if a0)
          (compile-if result ast env-type)

        (= 'defnativefn a0)
          (do
            (apply emit-native-func (rest ast))
            result)

        'else
          (compile-apply result ast env-type)))))

(def! compile-temp
  (fn* [ast env-type]
    (compile (new-reg) ast env-type)))

(def! compile-variable
  (fn* [result var-name env-type]
    (do
      (if (= env-type 'native-func)
        (emit-assign-to-reg result (str "%" var-name))
        (emit result "= TODO_get_env(var-name=" var-name ")"))
      result)))

(def! compile-elementarray
  (fn* [result type-num itemsregs env-type]
    (let* [type-reg (new-reg)
           len-reg (new-reg)]
      (do
        (compile type-reg type-num env-type)
        (compile len-reg (count itemsregs) env-type)
        (emit result "= call %mal_obj @mal_make_elementarray_obj(%mal_obj " type-reg ", %mal_obj " len-reg ")")
        (map-with-index (fn* [r index]
                              (let* [index-reg (new-reg)]
                                (do
                                  (compile-const-integer index-reg index)
                                  (emit "call %mal_obj @mal_set_elementarray_item("
                                        "%mal_obj" result
                                        ", %mal_obj" index-reg
                                        ", %mal_obj" r ")"))))
                        itemsregs)
        result))))

(def! compile-literal-list
  (fn* [result ast env-type]
    (let* [itemsregs (map (fn* [p] (compile-literal (new-reg) p env-type)) ast)]
      (compile-elementarray result 33 itemsregs env-type))))

(def! compile-vector
  (fn* [result ast env-type]
    (let* [itemsregs (map (fn* [p] (compile (new-reg) p env-type)) ast)]
      (compile-elementarray result 34 itemsregs env-type))))

(def! compile-literal
  (fn* [result ast env-type]
    (do
      (debug "compile-literal:" result ast)
      (cond
        (nil? ast) (compile-nil result)
        (true? ast) (compile-true result)
        (false? ast) (compile-false result)
        (number? ast) (compile-const-integer result ast)
        (symbol? ast) (compile-const-bytearray result 17 ast)
        (string? ast) (compile-const-bytearray result 18 ast)
        (keyword? ast) (compile-const-bytearray result 19 ast)
        (list? ast) (compile-literal-list result ast env-type)))))

(def! literal?
  (fn* [ast]
    (or (nil? ast)
        (true? ast)
        (false? ast)
        (number? ast)
        (symbol? ast)
        (string? ast)
        (keyword? ast))))

(def! expand-macros
  (fn* [ast]
    (if (list? ast)
      (eval (list 'macroexpand ast))
      ast)))

(def! compile
  (fn* [result ast env-type]
    (let* [exp-ast (expand-macros ast)
           x1 (debug "compile:" ast)
           x2 (debug "exp-ast:" exp-ast)]
      (cond
        (symbol? exp-ast) (compile-variable result exp-ast env-type)
        (literal? exp-ast) (compile-literal result exp-ast env-type)
        (list? exp-ast) (compile-list result exp-ast env-type)
        (vector? exp-ast) (compile-vector result exp-ast env-type)))))

(def! escape
  (fn* [s]
    (str "@\"" s "\"")))

(def! emit-function
  (fn* [name body]
    (do
      (emit "")
      (emit "")
      (emit "define private %mal_obj" (escape name) "() {")
      (compile "%funcresult" body 'mal)
      (emit "ret %mal_obj %funcresult")
      (emit "}"))))
      (emit "")

(def! emit-strings-list
  (fn* []
    (map emit @*strings-list*)))

(def! compile-program-string
  (fn* [s]
    (do
      (emit (slurp "header.ll"))
      (compile nil (read-string (str "(do " (slurp "nativefuncs.mal") ")")) 'native-func)
      (emit-function "mal_prog_main" (read-string (str "(do " s ")")))
      (emit-strings-list)
      (emit (slurp "footer.ll")))))

(def! compile-program-file
  (fn* [filename]
    (compile-program-string (slurp filename))))

(debug "Starting...")
(if (empty? *ARGV*)
  (println "Usage: malc source_filename")
  (compile-program-file (first *ARGV*)))
