(load-file "utils.mal")
(load-file "instructions.mal")


(def! *current-reg* (atom 0))
(def! new-reg
  (fn* []
    (str "%r" (swap! *current-reg* inc))))

(def! *current-string-global* (atom 0))
(def! *strings-list* (atom []))
(def! add-string
  (fn* [str-val]
    (let* [str-num (swap! *current-string-global* inc)
           str-global (str "@str." str-num)
           len (inc (string/length str-val))
           def-line (str str-global "= private constant [" len " x i8] c\"" str-val "\\00\"")]
      (do
        (swap! *strings-list* conj def-line)
        str-global))))

(def! debug
  (fn* [& args]
    (apply println "; DEBUG" args)))

(def! emit println)

(def! compile-const-integer
  (fn* [result num]
    (do
      (emit result "= call %mal_obj @make_integer(i64" num ")")
      result)))

(def! compile-const-bytearray
  (fn* [result type-num body]
    (let* [len-reg (new-reg)
           str-len (inc (string/length body))
           str-global (add-string body)]
      (do
        (emit len-reg "= add i32 0," str-len)
        (emit result "= call %mal_obj @make_bytearray_obj(i32 " type-num ", i32 " len-reg ", i8* getelementptr([" str-len " x i8]* " str-global ", i32 0, i32 0))")
        result))))

(def! compile-apply
  (fn* [result ast]
    (let* [funcname (first ast)
           funcobj (get *instructions* funcname)
           functype (first funcobj)
           funcdetails (rest funcobj)
           argregs (map compile-temp (rest ast))
           argregs-with-types (map (fn* [a] (str "%mal_obj " a)) argregs)]
      (do
        (debug "compile-apply:" result ast)
        (cond
          (= functype 'llvm-func)
            (emit result "= call %mal_obj" (first funcdetails) "(" (string/join ", " argregs-with-types) ")")
          'else
            (throw (str "Unknown function '" funcname "' type: " functype)))
        result))))

(def! compile-list
  (fn* [result ast]
    (let* [a0 (first ast)]
      (cond
        (= 'do a0)
          (let* [regs (map compile-temp (rest ast))]
            (do
              (emit result "= call %mal_obj @identity(%mal_obj " (last regs) ")")
              result))

        'else
          (compile-apply result ast)))))

(def! compile-temp
  (fn* [ast]
    (compile (new-reg) ast)))

(def! compile
  (fn* [result ast]
    (do
      (debug "compile:" result ast)
      (cond
        (number? ast) (compile-const-integer result ast)
        (symbol? ast) (compile-const-bytearray result 1 ast)
        (string? ast) (compile-const-bytearray result 2 ast)
        (keyword? ast) (compile-const-bytearray result 3 ast)
        (list? ast) (compile-list result ast)))))

(def! escape
  (fn* [s]
    (str "@\"" s "\"")))

(def! emit-function
  (fn* [name body]
    (do
      (emit "define private %mal_obj" (escape name) "() {")
      (compile "%funcresult" body)
      (emit "ret %mal_obj %funcresult")
      (emit "}"))))

(def! emit-strings-list
  (fn* []
    (map emit @*strings-list*)))

(def! compile-program-string
  (fn* [s]
    (do
      (emit (slurp "header.ll"))
      (emit-function "mal_prog_main" (read-string (str "(do " s ")")))
      (emit-strings-list)
      (emit (slurp "footer.ll")))))

(def! compile-program-file
  (fn* [filename]
    (compile-program-string (slurp filename))))

(debug "Starting...")
(if (empty? *ARGV*)
  (println "Usage: malc source_filename")
  (compile-program-file (first *ARGV*)))
