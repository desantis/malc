(defmacro! and
  (fn* (& xs)
    (if (empty? xs)
      true
      (if (= 1 (count xs))
        (first xs)
        `(let* (and_FIXME ~(first xs))
          (if and_FIXME (and ~@(rest xs)) and_FIXME))))))

(defmacro! or
  (fn* (& xs)
    (if (empty? xs)
      nil
      (if (= 1 (count xs))
        (first xs)
        `(let* (or_FIXME ~(first xs))
          (if or_FIXME or_FIXME (or ~@(rest xs))))))))

(defnativefn mal_and mal_and [x y] (if x y false))
(defnativefn mal_or mal_or [x y] (if x true y))

(defnativefn make-list make_list [len] (_make_elementarray_obj 33 len))
(defnativefn make-vector make_vector [len] (_make_elementarray_obj 34 len))
(defnativefn make-map make_map [len] (_make_elementarray_obj 35 len))

(defnativefn cons cons [x y]
  (_set_elementarray_item (_set_elementarray_item (make-list 2) 0 x) 1 y))

(defnativefn symbol?  symbol_Q  [obj] (_integer_equal? 17 (_get_type obj)))
(defnativefn string?  string_Q  [obj] (_integer_equal? 18 (_get_type obj)))
(defnativefn keyword? keyword_Q [obj] (_integer_equal? 19 (_get_type obj)))
(defnativefn list?    list_Q    [obj] (_integer_equal? 33 (_get_type obj)))
(defnativefn vector?  vector_Q  [obj] (_integer_equal? 34 (_get_type obj)))
(defnativefn map?     map_Q     [obj] (_integer_equal? 35 (_get_type obj)))
(defnativefn atom?    atom_Q    [obj] (_integer_equal? 49 (_get_type obj)))

(defnativefn equal_bytearray_content? equal_bytearray_content_Q [a b]
  (mal_and (_integer_equal? (_get_len a) (_get_len b)) (_bytearray_equal? a b)))

(defnativefn equal_bytearray_types? equal_bytearray_types_Q [a b]
  (cond
    (mal_and (symbol? a) (symbol? b)) (equal_bytearray_content? a b)
    (mal_and (string? a) (string? b)) (equal_bytearray_content? a b)
    (mal_and (keyword? a) (keyword? b)) (equal_bytearray_content? a b)
    :else false))

(defnativefn = equal_Q [a b]
  (cond
    (nil? a) (nil? b)
    (true? a) (true? b)
    (false? a) (false? b)
    (integer? a) (mal_and (integer? b) (_integer_equal? a b))
    (mal_or (mal_or (symbol? a) (string? a)) (keyword? a)) (equal_bytearray_types? a b)
    :else false)) ; TODO vector/list/map/atom

(defnativefn count count [obj] (_get_len obj))
(defnativefn empty? empty_Q [obj] (= 0 (count obj)))
(defnativefn first first [seq]
  (if (empty? seq)
    nil
    (_get_elementarray_item seq 0)))

(defnativefn printobj printobj [obj]
  (cond
    (nil? obj) (_printbytearray "nil")
    (false? obj) (_printbytearray "false")
    (true? obj) (_printbytearray "true")
    (integer? obj) (_printnumber obj)
    (symbol? obj) (_printbytearray obj)
    (keyword? obj) (_printbytearray obj)
    (string? obj)
      (do
        (_printbytearray "{") ; "\"")
        (_printbytearray obj)
        (_printbytearray "}")) ; "\""))
    :else
      (do
        (_printbytearray "DONT-KNOW-HOW-TO-PRINT:raw=")
        (_printraw obj))))

(defnativefn printlnobj printlnobj [obj]
  (do
    (printobj obj)
    (_printnewline)))
