;;
;; Declare LLVM functions (implemented in header.ll)
;;
(defnativefn + mal_add [a b])
(defnativefn - mal_sub [a b])
(defnativefn * mal_mul [a b])
(defnativefn / mal_div [a b])
(defnativefn _integer_equal? mal_integer_equal_q [a b])
(defnativefn >  mal_integer_gt_q  [a b])
(defnativefn >= mal_integer_gte_q [a b])
(defnativefn <  mal_integer_lt_q  [a b])
(defnativefn <= mal_integer_lte_q [a b])

(defnativefn integer? mal_integer_q [obj])
(defnativefn nil?     mal_nil_q [obj])
(defnativefn false?   mal_false_q [obj])
(defnativefn true?    mal_true_q [obj])

(defnativefn _make_elementarray_obj mal_make_elementarray_obj [objtype len_elements])
(defnativefn _get_type              mal_get_type [obj])
(defnativefn _get_len               mal_get_len [obj])
(defnativefn _set_elementarray_item mal_set_elementarray_item [obj item_index new_item])
(defnativefn _get_elementarray_item mal_get_elementarray_item [obj item_index])
(defnativefn _concat_elementarrays  mal_concat_elementarrays [objtype a b])
(defnativefn _slice_elementarray    mal_slice_elementarray [newobjtype obj from len])
(defnativefn _bytearray_equal?      mal_bytearray_equal_q [a b])

(defnativefn _printchar      mal_printchar [obj])
(defnativefn _printnumber    mal_printnumber [obj])
(defnativefn _printraw       mal_printraw [obj])
(defnativefn _printbytearray mal_printbytearray [obj])

(defnativefn native-func-apply-list mal_native_func_apply_list [fn argslist])
(defnativefn func-apply-list mal_func_apply_list [fn argslist])

(defnativefn time-ms mal_time_ms [])
(defnativefn os-exit mal_os_exit [exitcode])
(defnativefn readline mal_readline [prompt])
(defnativefn slurp mal_slurp [filename])

;;
;; Forward declaration
;;
(defnativefn printobj printobj [obj readable])
(defnativefn printlnobj printlnobj [obj readable])
(defnativefn deref deref [atm])

;;
;; Runtime error
;;
(defnativefn runtime-error runtime_error [msg]
  (do
    (printlnobj msg false)
    (os-exit 1)))

(defnativefn make-list make_list [len] (_make_elementarray_obj 33 len))
(defnativefn make-vector make_vector [len] (_make_elementarray_obj 34 len))
(defnativefn make-map make_map [len] (_make_elementarray_obj 35 len))
(defnativefn make-atom make_atom [] (_make_elementarray_obj 49 1))
(defnativefn make-env make_env [] (_make_elementarray_obj 65 2))
(defnativefn make-func make_func [] (_make_elementarray_obj 66 3))
(defnativefn make-native-func make_native_func [] (_make_elementarray_obj 67 3))

(defnativefn cons cons [x y]
  (_set_elementarray_item (_set_elementarray_item (make-list 2) 0 x) 1 y))

(defnativefn symbol?  symbol_Q  [obj] (_integer_equal? 17 (_get_type obj)))
(defnativefn string?  string_Q  [obj] (_integer_equal? 18 (_get_type obj)))
(defnativefn keyword? keyword_Q [obj] (_integer_equal? 19 (_get_type obj)))
(defnativefn list?    list_Q    [obj] (_integer_equal? 33 (_get_type obj)))
(defnativefn vector?  vector_Q  [obj] (_integer_equal? 34 (_get_type obj)))
(defnativefn map?     map_Q     [obj] (_integer_equal? 35 (_get_type obj)))
(defnativefn atom?    atom_Q    [obj] (_integer_equal? 49 (_get_type obj)))
(defnativefn function? function_Q [obj] (_integer_equal? 66 (_get_type obj)))
(defnativefn native-function? native_function_Q [obj] (_integer_equal? 67 (_get_type obj)))

(defnativefn sequential? sequential_Q [obj]
  (if (list? obj) true (vector? obj)))

(defnativefn equal_bytearray_content? equal_bytearray_content_Q [a b]
  (if (_integer_equal? (_get_len a) (_get_len b))
    (_bytearray_equal? a b)
    false))

(defnativefn = equal_Q [a b]
  (cond
    (nil? a)     (nil? b)
    (true? a)    (true? b)
    (false? a)   (false? b)
    (integer? a) (if (integer? b) (_integer_equal? a b) false)
    (symbol? a)  (if (symbol? b)  (equal_bytearray_content? a b))
    (string? a)  (if (string? b)  (equal_bytearray_content? a b))
    (keyword? a) (if (keyword? b) (equal_bytearray_content? a b))
    (atom? a)    (if (atom? b) (= @a @b) false)
    :else        false)) ; TODO vector/list/map

(defnativefn count count [obj] (_get_len obj))
(defnativefn empty? empty_Q [obj] (= 0 (count obj)))
(defnativefn first first [seq]
  (if (empty? seq)
    nil
    (_get_elementarray_item seq 0)))

(defnativefn last last [seq]
  (if (empty? seq)
    nil
    (_get_elementarray_item seq (- (_get_len seq) 1))))

(defnativefn drop drop [seq nitems]
  (if (> (count seq) nitems)
    (_slice_elementarray 33 seq nitems (- (count seq) nitems))
    (make-list 0)))

(defnativefn rest rest [seq]
  (drop seq 1))

(defnativefn nth nth [seq index]
  (if (>= index (count seq))
    (runtime-error "nth: index out of range")
    (_get_elementarray_item seq index)))

(defnativefn concat-helper concat_helper [result lists]
  (if (empty? lists)
    result
    (concat-helper (_concat_elementarrays 33 result (first lists)) (rest lists))))

(defnativefn hash-map-from-list hash_map_from_list [lst]
  (_concat_elementarrays 35 lst []))

(defnativefn get-helper get_helper [hm key index]
  (if (>= index (_get_len hm))
    nil
    (if (= (nth hm index) key)
      (nth hm (+ 1 index))
      (get-helper hm key (+ 2 index)))))

(defnativefn get get [hm key]
  (get-helper hm key 0))

(defnativefn contains-helper contains_helper [hm key index]
  (if (>= index (_get_len hm))
    false
    (if (= (nth hm index) key)
      true
      (contains-helper hm key (+ 2 index)))))

(defnativefn contains? contains_Q [hm key]
  (contains-helper hm key 0))

(defnativefn dissoc1-helper dissoc1_helper [hm key index result]
  (if (>= index (_get_len hm))
    result
    (if (= (nth hm index) key)
      (dissoc1-helper hm key (+ 2 index) result)
      (dissoc1-helper hm key (+ 2 index) (_concat_elementarrays 35 result [(nth hm index) (nth hm (+ 1 index))])))))

(defnativefn dissoc1 dissoc1 [hm key]
  (if (contains? hm key)
    (dissoc1-helper hm key 0 [])
    hm))

(defnativefn assoc1 assoc1 [hm key val]
  (_concat_elementarrays 35 (dissoc1 hm key) [key val]))

(defnativefn keys-vals-helper keys_vals_helper [hm hm_index result result_index]
  (if (>= hm_index (_get_len hm))
    result
    (do
      (_set_elementarray_item result result_index (nth hm hm_index))
      (keys-vals-helper hm (+ 2 hm_index) result (+ 1 result_index)))))

(defnativefn keys keys [hm]
  (keys-vals-helper hm 0 (make-list (/ (_get_len hm) 2)) 0))

(defnativefn vals vals [hm]
  (keys-vals-helper hm 1 (make-list (/ (_get_len hm) 2)) 0))

;;
;; Atoms
;;
(defnativefn atom atom [val]
  (_set_elementarray_item (make-atom) 0 val))

(defnativefn deref deref [atm]
  (_get_elementarray_item atm 0))

(defnativefn reset! reset_BANG [atm val]
  (do
    (_set_elementarray_item atm 0 val)
    val))

;;
;; Env
;;
(defnativefn env-bind-vars env_bind_vars [res binds exprs index]
  (if (>= index (count binds))
    res
    (if (= '& (nth binds index))
      (assoc1 res (nth binds (+ 1 index)) (drop exprs index))
      (env-bind-vars (assoc1 res (nth binds index) (nth exprs index)) binds exprs (+ 1 index)))))

(defnativefn init-env init_env [outer data]
  (_set_elementarray_item (_set_elementarray_item (make-env) 0 outer) 1 data))

(defnativefn new-env new_env [outer binds exprs]
  (init-env outer (env-bind-vars (make-map 0) binds exprs 0)))

(defnativefn new-root-env new_root_env []
  (new-env nil [] []))

(defnativefn env-outer env_outer [env] (first env))
(defnativefn env-data env_data [env] (nth env 1))

(defnativefn env-find env_find [env k]
  (if (contains? (env-data env) k)
    env
    (if (env-outer env)
      (env-find (env-outer env) k)
      nil)))

(defnativefn env-get-helper env_get_helper [found-env k]
  (if found-env
    (get (env-data found-env) k)
    (runtime-error [k "not found"])))

(defnativefn env-get env_get [env k]
  (env-get-helper (env-find env k) k))

(defnativefn env-set env_set [env k v]
  (do
    (_set_elementarray_item env 1 (assoc1 (env-data env) k v))
    v))

;;
;; apply and map
(defnativefn apply-helper apply_helper [fn argslist]
  (if (native-function? fn)
    (native-func-apply-list fn argslist)
    (func-apply-list fn argslist)))


(defnativefn map-helper map_helper [result index fn seq]
  (if (>= index (count seq))
    result
    (do
      (_set_elementarray_item result index (apply-helper fn [(nth seq index)]))
      (map-helper result (+ 1 index) fn seq))))

(defnativefn map map [fn seq]
  (map-helper (make-list (count seq)) 0 fn seq))

;;
;; Function
;;
(defnativefn fn-args-names fn_args_names [fn]
  (_get_elementarray_item fn 0))

(defnativefn fn-env fn_env [fn]
  (_get_elementarray_item fn 1))

(defnativefn fn-func-ptr fn_func_ptr [fn]
  (_get_elementarray_item fn 2))

(defnativefn nativefn-name nativefn_name [fn]
  (_get_elementarray_item fn 1))

(defnativefn printelements printelements [obj readable index]
  (if (>= index (_get_len obj))
    nil
    (do
      (if (> index 0) (printobj " " false))
      (printobj (nth obj index) readable)
      (printelements obj readable (+ 1 index)))))

(defnativefn printsequence printsequence [obj readable startchar endchar]
  (do
    (_printbytearray startchar)
    (printelements obj readable 0)
    (_printbytearray endchar)))

(defnativefn printobj printobj [obj readable]
  (cond
    (nil? obj) (_printbytearray "nil")
    (false? obj) (_printbytearray "false")
    (true? obj) (_printbytearray "true")
    (integer? obj) (_printnumber obj)
    (symbol? obj) (_printbytearray obj)
    (keyword? obj) (_printbytearray obj)
    (string? obj)
      (if readable
        (do
          (_printchar 34) ; quote
          (_printbytearray obj)
          (_printchar 34)) ; quote
        (_printbytearray obj))
    (list? obj)   (printsequence obj readable "(" ")")
    (vector? obj) (printsequence obj readable "[" "]")
    (map? obj)    (printsequence obj readable "{" "}")
    (atom? obj)
      (do
        (_printbytearray "(atom ")
        (printobj (deref obj) readable)
        (_printbytearray ")"))
    (function? obj)
      (do
        (_printbytearray "#<function args=")
        (printobj (fn-args-names obj) readable)
        (_printbytearray ">"))
    (native-function? obj)
      (do
        (_printbytearray "#<native-function ")
        (_printbytearray (nativefn-name obj))
        (_printbytearray " args=")
        (printobj (fn-args-names obj) readable)
        (_printbytearray ">"))
    :else
      (do
        (_printbytearray "#<DONT-KNOW-HOW-TO-PRINT:raw=")
        (_printraw obj)
        (_printbytearray ">"))))

(defnativefn _printnewline _printnewline []
  (_printchar 10))

(defnativefn printlnobj printlnobj [obj readable]
  (do
    (printobj obj readable)
    (_printnewline)))
