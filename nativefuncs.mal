(defmacro! and
  (fn* (& xs)
    (if (empty? xs)
      true
      (if (= 1 (count xs))
        (first xs)
        `(let* (and_FIXME ~(first xs))
          (if and_FIXME (and ~@(rest xs)) and_FIXME))))))

(defmacro! or
  (fn* (& xs)
    (if (empty? xs)
      nil
      (if (= 1 (count xs))
        (first xs)
        `(let* (or_FIXME ~(first xs))
          (if or_FIXME or_FIXME (or ~@(rest xs))))))))

;;
;; Declare LLVM functions (implemented in header.ll)
;;
(defnativefn + mal_add [a b])
(defnativefn - mal_sub [a b])
(defnativefn * mal_mul [a b])
(defnativefn / mal_div [a b])
(defnativefn _integer_equal? mal_integer_equal_q [a b])

(defnativefn integer? mal_integer_q [obj])
(defnativefn nil?     mal_nil_q [obj])
(defnativefn false?   mal_false_q [obj])
(defnativefn true?    mal_true_q [obj])

(defnativefn _make_elementarray_obj mal_make_elementarray_obj [objtype len_elements])
(defnativefn _get_type              mal_get_type [obj])
(defnativefn _get_len               mal_get_len [obj])
(defnativefn _set_elementarray_item mal_set_elementarray_item [obj item_index new_item])
(defnativefn _get_elementarray_item mal_get_elementarray_item [obj item_index])
(defnativefn _concat_elementarrays  mal_concat_elementarrays [objtype a b])
(defnativefn _bytearray_equal?      mal_bytearray_equal_q [a b])

(defnativefn _printchar      mal_printchar [obj])
(defnativefn _printnumber    mal_printnumber [obj])
(defnativefn _printraw       mal_printraw [obj])
(defnativefn _printbytearray mal_printbytearray [obj])

(defnativefn time-ms mal_time_ms [])

;;
;; Simple boolean operations for native functions
;;
(defnativefn mal_and mal_and [x y] (if x y false))
(defnativefn mal_or mal_or [x y] (if x true y))
(defnativefn mal_not mal_not [x] (if x false true))

(defnativefn make-list make_list [len] (_make_elementarray_obj 33 len))
(defnativefn make-vector make_vector [len] (_make_elementarray_obj 34 len))
(defnativefn make-map make_map [len] (_make_elementarray_obj 35 len))
(defnativefn make-atom make_atom [] (_make_elementarray_obj 49 1))
(defnativefn make-env make_env [] (_make_elementarray_obj 65 2))
(defnativefn make-func make_func [] (_make_elementarray_obj 66 3))

(defnativefn cons cons [x y]
  (_set_elementarray_item (_set_elementarray_item (make-list 2) 0 x) 1 y))

(defnativefn symbol?  symbol_Q  [obj] (_integer_equal? 17 (_get_type obj)))
(defnativefn string?  string_Q  [obj] (_integer_equal? 18 (_get_type obj)))
(defnativefn keyword? keyword_Q [obj] (_integer_equal? 19 (_get_type obj)))
(defnativefn list?    list_Q    [obj] (_integer_equal? 33 (_get_type obj)))
(defnativefn vector?  vector_Q  [obj] (_integer_equal? 34 (_get_type obj)))
(defnativefn map?     map_Q     [obj] (_integer_equal? 35 (_get_type obj)))
(defnativefn atom?    atom_Q    [obj] (_integer_equal? 49 (_get_type obj)))
(defnativefn function? function_Q [obj] (_integer_equal? 66 (_get_type obj)))

(defnativefn equal_bytearray_content? equal_bytearray_content_Q [a b]
  (mal_and (_integer_equal? (_get_len a) (_get_len b)) (_bytearray_equal? a b)))

(defnativefn equal_bytearray_types? equal_bytearray_types_Q [a b]
  (cond
    (mal_and (symbol? a) (symbol? b)) (equal_bytearray_content? a b)
    (mal_and (string? a) (string? b)) (equal_bytearray_content? a b)
    (mal_and (keyword? a) (keyword? b)) (equal_bytearray_content? a b)
    :else false))

(defnativefn = equal_Q [a b]
  (cond
    (nil? a) (nil? b)
    (true? a) (true? b)
    (false? a) (false? b)
    (integer? a) (mal_and (integer? b) (_integer_equal? a b))
    (mal_or (mal_or (symbol? a) (string? a)) (keyword? a)) (equal_bytearray_types? a b)
    :else false)) ; TODO vector/list/map/atom

(defnativefn count count [obj] (_get_len obj))
(defnativefn empty? empty_Q [obj] (= 0 (count obj)))
(defnativefn first first [seq]
  (if (empty? seq)
    nil
    (_get_elementarray_item seq 0)))

(defnativefn nth nth [seq index]
  ; TODO check boundaries
  (_get_elementarray_item seq index))

(defnativefn hash-map-from-list hash_map_from_list [lst]
  (_concat_elementarrays 35 lst []))

(defnativefn get-helper get_helper [hm key index]
  (if (= (_get_len hm) index)
    nil
    (if (= (nth hm index) key)
      (nth hm (+ 1 index))
      (get-helper hm key (+ 2 index)))))

(defnativefn get get [hm key]
  (get-helper hm key 0))

(defnativefn contains-helper contains_helper [hm key index]
  (if (= (_get_len hm) index)
    false
    (if (= (nth hm index) key)
      true
      (contains-helper hm key (+ 2 index)))))

(defnativefn contains? contains_Q [hm key]
  (contains-helper hm key 0))

(defnativefn dissoc1-helper dissoc1_helper [hm key index result]
  (if (= (_get_len hm) index)
    result
    (if (= (nth hm index) key)
      (dissoc1-helper hm key (+ 2 index) result)
      (dissoc1-helper hm key (+ 2 index) (_concat_elementarrays 35 result [(nth hm index) (nth hm (+ 1 index))])))))

(defnativefn dissoc1 dissoc1 [hm key]
  (if (contains? hm key)
    (dissoc1-helper hm key 0 [])
    hm))

(defnativefn assoc1 assoc1 [hm key val]
  (_concat_elementarrays 35 (dissoc1 hm key) [key val]))

;;
;; Atoms
;;
(defnativefn atom atom [val]
  (_set_elementarray_item (make-atom) 0 val))

(defnativefn deref deref [atom]
  (_get_elementarray_item atom 0))

(defnativefn reset! reset_BANG [atom val]
  (do
    (_set_elementarray_item atom 0 val)
    val))

;;
;; Env
;;
(defnativefn env-bind-vars env_bind_vars [res binds exprs index]
  (if (= (count binds) index)
    res
    (env-bind-vars (assoc1 res (nth binds index) (nth exprs index)) binds exprs (+ 1 index))))

(defnativefn init-env init_env [outer data]
  (_set_elementarray_item (_set_elementarray_item (make-env) 0 outer) 1 data))

(defnativefn new-env new_env [outer binds exprs]
  (init-env outer (env-bind-vars (make-map 0) binds exprs 0)))

(defnativefn new-root-env new_root_env []
  (new-env nil [] []))

(defnativefn env-outer env_outer [env] (first env))
(defnativefn env-data env_data [env] (nth env 1))

(defnativefn env-find env_find [env k]
  (if (contains? (env-data env) k)
    env
    (if (env-outer env)
      (env-find (env-outer env) k)
      nil)))

(defnativefn env-get-helper env_get_helper [found-env k]
  (if found-env
    (get (env-data found-env) k)
    nil))

(defnativefn env-get env_get [env k]
  (env-get-helper (env-find env k) k))

(defnativefn env-set env_set [env k v]
  (do
    (_set_elementarray_item env 1 (assoc1 (env-data env) k v))
    v))

;;
;; Function
;;
(defnativefn fn-args-names fn_args_names [fn]
  (_get_elementarray_item fn 0))

(defnativefn fn-env fn_env [fn]
  (_get_elementarray_item fn 1))

(defnativefn fn-func-ptr fn_func_ptr [fn]
  (_get_elementarray_item fn 2))

;; forward declaration
(defnativefn printobj printobj [obj readable])

(defnativefn printelements printelements [obj readable index]
  (if (= (_get_len obj) index)
    nil
    (do
      (if (mal_not (= index 0)) (printobj " " false))
      (printobj (nth obj index) readable)
      (printelements obj readable (+ 1 index)))))

(defnativefn printsequence printsequence [obj readable startchar endchar]
  (do
    (_printbytearray startchar)
    (printelements obj readable 0)
    (_printbytearray endchar)))

(defnativefn printobj printobj [obj readable]
  (cond
    (nil? obj) (_printbytearray "nil")
    (false? obj) (_printbytearray "false")
    (true? obj) (_printbytearray "true")
    (integer? obj) (_printnumber obj)
    (symbol? obj) (_printbytearray obj)
    (keyword? obj) (_printbytearray obj)
    (string? obj)
      (if readable
        (do
          (_printchar 34) ; quote
          (_printbytearray obj)
          (_printchar 34)) ; quote
        (_printbytearray obj))
    (list? obj)   (printsequence obj readable "(" ")")
    (vector? obj) (printsequence obj readable "[" "]")
    (map? obj)    (printsequence obj readable "{" "}")
    (atom? obj)
      (do
        (_printbytearray "(atom ")
        (printobj (deref obj) readable)
        (_printbytearray ")"))
    (function? obj)
      (do
        (_printbytearray "#<function args=")
        (printobj (fn-args-names obj) readable)
        (_printbytearray ">"))
    :else
      (do
        (_printbytearray "#<DONT-KNOW-HOW-TO-PRINT:raw=")
        (_printraw obj)
        (_printbytearray ">"))))

(defnativefn _printnewline _printnewline []
  (_printchar 10))

(defnativefn printlnobj printlnobj [obj readable]
  (do
    (printobj obj readable)
    (_printnewline)))
