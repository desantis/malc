(defmacro! and
  (fn* (& xs)
    (if (empty? xs)
      true
      (if (= 1 (count xs))
        (first xs)
        `(let* (and_FIXME ~(first xs))
          (if and_FIXME (and ~@(rest xs)) and_FIXME))))))

(defmacro! or
  (fn* (& xs)
    (if (empty? xs)
      nil
      (if (= 1 (count xs))
        (first xs)
        `(let* (or_FIXME ~(first xs))
          (if or_FIXME or_FIXME (or ~@(rest xs))))))))

(defnativefn mal_and mal_and [x y] (if x y false))
(defnativefn mal_or mal_or [x y] (if x true y))
(defnativefn mal_not mal_not [x] (if x false true))

(defnativefn make-list make_list [len] (_make_elementarray_obj 33 len))
(defnativefn make-vector make_vector [len] (_make_elementarray_obj 34 len))
(defnativefn make-map make_map [len] (_make_elementarray_obj 35 len))
(defnativefn make-atom make_atom [] (_make_elementarray_obj 49 1))

(defnativefn cons cons [x y]
  (_set_elementarray_item (_set_elementarray_item (make-list 2) 0 x) 1 y))

(defnativefn symbol?  symbol_Q  [obj] (_integer_equal? 17 (_get_type obj)))
(defnativefn string?  string_Q  [obj] (_integer_equal? 18 (_get_type obj)))
(defnativefn keyword? keyword_Q [obj] (_integer_equal? 19 (_get_type obj)))
(defnativefn list?    list_Q    [obj] (_integer_equal? 33 (_get_type obj)))
(defnativefn vector?  vector_Q  [obj] (_integer_equal? 34 (_get_type obj)))
(defnativefn map?     map_Q     [obj] (_integer_equal? 35 (_get_type obj)))
(defnativefn atom?    atom_Q    [obj] (_integer_equal? 49 (_get_type obj)))

(defnativefn equal_bytearray_content? equal_bytearray_content_Q [a b]
  (mal_and (_integer_equal? (_get_len a) (_get_len b)) (_bytearray_equal? a b)))

(defnativefn equal_bytearray_types? equal_bytearray_types_Q [a b]
  (cond
    (mal_and (symbol? a) (symbol? b)) (equal_bytearray_content? a b)
    (mal_and (string? a) (string? b)) (equal_bytearray_content? a b)
    (mal_and (keyword? a) (keyword? b)) (equal_bytearray_content? a b)
    :else false))

(defnativefn = equal_Q [a b]
  (cond
    (nil? a) (nil? b)
    (true? a) (true? b)
    (false? a) (false? b)
    (integer? a) (mal_and (integer? b) (_integer_equal? a b))
    (mal_or (mal_or (symbol? a) (string? a)) (keyword? a)) (equal_bytearray_types? a b)
    :else false)) ; TODO vector/list/map/atom

(defnativefn count count [obj] (_get_len obj))
(defnativefn empty? empty_Q [obj] (= 0 (count obj)))
(defnativefn first first [seq]
  (if (empty? seq)
    nil
    (_get_elementarray_item seq 0)))

(defnativefn nth nth [seq index]
  ; TODO check boundaries
  (_get_elementarray_item seq index))

(defnativefn hash-map-from-list hash_map_from_list [lst]
  (_concat_elementarrays 35 lst []))

(defnativefn get-helper get_helper [hm key index]
  (if (= (_get_len hm) index)
    nil
    (if (= (nth hm index) key)
      (nth hm (+ 1 index))
      (get-helper hm key (+ 2 index)))))

(defnativefn get get [hm key]
  (get-helper hm key 0))

(defnativefn contains-helper contains_helper [hm key index]
  (if (= (_get_len hm) index)
    false
    (if (= (nth hm index) key)
      true
      (contains-helper hm key (+ 2 index)))))

(defnativefn contains? contains_Q [hm key]
  (contains-helper hm key 0))

(defnativefn dissoc1-helper dissoc1_helper [hm key index result]
  (if (= (_get_len hm) index)
    result
    (if (= (nth hm index) key)
      (dissoc1-helper hm key (+ 2 index) result)
      (dissoc1-helper hm key (+ 2 index) (_concat_elementarrays 35 result [(nth hm index) (nth hm (+ 1 index))])))))

(defnativefn dissoc1 dissoc1 [hm key]
  (if (contains? hm key)
    (dissoc1-helper hm key 0 [])
    hm))

(defnativefn assoc1 assoc1 [hm key val]
  (_concat_elementarrays 35 (dissoc1 hm key) [key val]))

;;
;; Atoms
;;
(defnativefn atom atom [val]
  (_set_elementarray_item (make-atom) 0 val))

(defnativefn deref deref [atom]
  (_get_elementarray_item atom 0))

(defnativefn reset! reset_BANG [atom val]
  (do
    (_set_elementarray_item atom 0 val)
    val))

;; forward declaration
(defnativefn printobj printobj [obj readable])

(defnativefn printelements printelements [obj readable index]
  (if (= (_get_len obj) index)
    nil
    (do
      (if (mal_not (= index 0)) (printobj " " readable))
      (printobj (nth obj index) readable)
      (printelements obj readable (+ 1 index)))))

(defnativefn printobj printobj [obj readable]
  (cond
    (nil? obj) (_printbytearray "nil")
    (false? obj) (_printbytearray "false")
    (true? obj) (_printbytearray "true")
    (integer? obj) (_printnumber obj)
    (symbol? obj) (_printbytearray obj)
    (keyword? obj) (_printbytearray obj)
    (string? obj)
      (if readable
        (do
          (_printchar 34) ; quote
          (_printbytearray obj)
          (_printchar 34)) ; quote
        (_printbytearray obj))
    (map? obj)
      (do
        (_printbytearray "{") ; "\"")
        (printelements obj readable 0)
        (_printbytearray "}")) ; "\""))
    (atom? obj)
      (do
        (_printbytearray "(atom ")
        (printobj (deref obj) readable)
        (_printbytearray ")")) ; "\""))
    :else
      (do
        (_printbytearray "DONT-KNOW-HOW-TO-PRINT:raw=")
        (_printraw obj))))

(defnativefn _printnewline _printnewline []
  (_printchar 10))

(defnativefn printlnobj printlnobj [obj readable]
  (do
    (printobj obj readable)
    (_printnewline)))
